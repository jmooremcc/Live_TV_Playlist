import os, sys
from threading import Event as Signal, Thread
import sys
from Queue import Queue
import xbmc
import xbmcaddon
import xbmcgui
from resources.lib.Data.PlayListItem import PlayListItem
from resources.PL_Client import PL_Client, genericDecode
from resources.lib.Utilities.Messaging import Cmd, NotificationAction
from resources.lib.Network.SecretSauce import *
import contextmenu
from Countdown import StartCountdownService
#import utility



MODULEDEBUGMODE=True

addon       = xbmcaddon.Addon()
addonID     = addon.getAddonInfo('id')
addonname   = addon.getAddonInfo('name')
addonpath   = addon.getAddonInfo('path').decode('utf-8')
xmlpath     = os.path.join(addonpath,'resources/skins/Default/720p/dialog.xml')
fanartpath  = os.path.join(addonpath,'fanart.jpg')
bgdimage    = os.path.join(addonpath,'resources/skins/Default/media','WhiteBlank.png')


#defaultskin = os.path(addonpath,'resources/skins/default/skin.xml')
YELLOW="FFBBBB00"
ORANGE="FFBB6600"
ITEM_BGDCOLOR='33FF00FF'
HDR_BGDCOLOR='FFAA0000'

#Control IDs
PAGE_SIZE                   = 10
CLOSE_BUTTON                = 20
SCROLL_BAR                  = 17
MAIN_LIST                   = 50

ACTION_MOVE_LEFT            = 1
ACTION_MOVE_RIGHT           = 2
ACTION_MOVE_UP              = 3
ACTION_MOVE_DOWN            = 4
ACTION_PAGE_UP              = 5
ACTION_PAGE_DOWN            = 6
ACTION_SELECT_ITEM          = 7
ACTION_PREVIOUS_MENU        = 10
ACTION_NAV_BACK             = 92

JUSTIFY_LEFT                = 0
JUSTIFY_CENTER              = 2
JUSTIFY_RIGHT               = 1

MENU_DELETE_ITEM            = 0
MENU_SKIP_ITEM              = 1
MENU_SUSPEND_ITEM           = 2

WINDOW_TV_GUIDE             = 10702

HDR_FORMAT = [('Date', 100, JUSTIFY_CENTER),('Time', 100, JUSTIFY_CENTER),('Ch',100, JUSTIFY_CENTER),
                  ('Frequency', 120, JUSTIFY_CENTER), ('Description', 200, JUSTIFY_LEFT), ('Expires On', 120, JUSTIFY_CENTER)]

ContextMenuItems = [('Skip Event',MENU_SKIP_ITEM),('Suspend Event',MENU_SUSPEND_ITEM),('Delete Event',MENU_DELETE_ITEM)]

LTVPL_HEADER = "Live TV Playlist"


def TS_decorator(func):
    def stub(*args, **kwargs):
        func(*args, **kwargs)

    def hook(*args,**kwargs):
        Thread(target=stub, args=args).start()

    return hook

def myLog(*args):
    xbmc.log(*args)
#from utility import myLog, TS_decorator

myLog("addonname: %s" % addonname)
myLog("addonID: %s" % addonID)
myLog("xmlpath: %s" % xmlpath)
myLog("addonpath: %s" % addonpath)
myLog("bgdimage: %s" % bgdimage)

class myBusyDialog(object):
    def __init__(self):
        self.stopFlag = False
        self.dialog = xbmcgui.DialogBusy()


    @TS_decorator
    def show(self):
        count = 0
        percent = 0
        #dialog = xbmcgui.DialogProgress()

        #dialog = xbmc.executebuiltin("ActivateWindow(busydialog)")
        self.dialog.create()
        myLog("***Busy Dialog Show")

        while not self.stopFlag and count < 100 and not self.dialog.iscanceled():
            xbmc.log("****Updating BusyDialog...")
            self.dialog.update(percent)
            percent = (percent + 5) % 100
            count += 1
            xbmc.sleep(330)

        self.dialog.close()

    @TS_decorator
    def DelayedStop(self, delay):
        totalMS = delay * 1000
        xbmc.sleep(totalMS)
        self.stopFlag = True
        myLog("****%s Second Delayed Busy Dialog Closing" % delay)

    def Stop(self, delay=0):
        myLog("******Dialog Stop Delay = %s" % delay)
        if delay == 0:
            self.stopFlag = True
            myLog("****Busy Dialog Closing")
        else:
            self.DelayedStop(delay)


def strTimeStamp(tData):
    """
    :type alarmtime: datetime
    :return: tuple(strDate, strTime)
    """
    try:
        strDate = "{:%m/%d/%Y}".format(tData)
        strTime = "{:%I:%M %p}".format(tData)
    except:
        strDate = strTime = ''

    return (strDate, strTime)

def getEPG_Data(win=None):
    pgmTitle = xbmc.getInfoLabel('Listitem.Title')
    pgmDate = xbmc.getInfoLabel('Listitem.Date')[:10]
    pgmTime = xbmc.getInfoLabel('Listitem.StartTime')
    pgmCh = xbmc.getInfoLabel('Listitem.ChannelNumberLabel')
    pgmIcon = xbmc.getInfoLabel('Listitem.Icon')
    # pos = win.getCurrentListPosition()
    myLog("****item title: %s " % pgmTitle)
    myLog("****item date: %s " % pgmDate)
    myLog("****item time: %s " % pgmTime)
    myLog("****item ch: %s " % pgmCh)
    myLog("****item icon: %s " % pgmIcon)

    #item = xbmcgui.ListItem()
    if win is not None:
        win.setProperty('pgmTitle',pgmTitle)
        win.setProperty('pgmDate', pgmDate)
        win.setProperty('pgmTime', pgmTime)
        win.setProperty('pgmCh', pgmCh)
        win.setProperty('pgmIcon', pgmIcon)
        win.setProperty('pgmExpiration','')

    #return item

def checkForEPG():
    bflag = xbmc.getCondVisibility("Window.IsVisible(tvguide)")
    myLog("********EPG Visible: %s" % bflag)
    return bflag



def getHdrKeys():
    keys = [w[0].split()[0] for w in HDR_FORMAT]
    return keys


def BuildHeader():
    item = xbmcgui.ListItem()
    for val in HDR_FORMAT:
        strval = "%s " % val[0]
        myLog(strval)
        label=val[0].split()[0]
        item.setProperty(label,val[0])
        #item.setProperty(label+'width', str(val[1]))


    return item


def BuildPlaylistItem(data):
    item = xbmcgui.ListItem()
    obj = PlayListItem()
    obj.Data = data
    widths = [w for w in HDR_FORMAT]
    for w in widths:
        myLog("item: %s:%s" % (w[0], w[1]))
        if w[0] == 'Date':
            strDate, strTime = strTimeStamp(obj.alarmtime)
            label = w[0].split()[0]
            item.setProperty(label, strDate)
            #item.setProperty(label, strDate)
            label = widths[1][0].split()[0]
            item.setProperty(label, strTime)

        elif w[0] == 'Ch':
            label = w[0].split()[0]
            item.setProperty(label, str(obj.ch))

        elif w[0] == 'Frequency':
            label = w[0].split()[0]
            item.setProperty(label, str(obj.recurrenceInterval))

        elif w[0] == 'Description':
            label = w[0].split()[0]
            item.setProperty(label, obj.title)

        elif w[0] == 'Expires On':
            strDate, strTime = strTimeStamp(obj.expiryDate)
            label = w[0].split()[0]
            item.setProperty(label, strDate)

        label = "ID"
        item.setProperty(label, obj.ID)

    return item


class GUI(xbmcgui.WindowXMLDialog):
    def __new__(cls, defaultSkin, defaultRes, bDialog, queue):
        return super(GUI, cls).__new__(cls, 'mainDialog.xml', xbmcaddon.Addon(addonID).getAddonInfo('path'), defaultSkin, defaultRes)

    def __init__(self, defaultSkin, defaultRes, bDialog, queue, *args, **kwargs):
        super(GUI, self).__init__(*args, **kwargs)

        #address = ('localhost', ServerPort)
        self.client = None
        self.signal = Signal()
        self.blockNotification = False
        self.shutdown = False
        self.currentPos = (0,0)
        self.width = 900
        self.height = 400
        self.setProperty('Go','0')
        myLog("***Showing Busy Dialog")
        self.bDialog = bDialog
        self.queue = queue
        #self.resolution = utility.translateResolution(self.getResolution())
        self.resolution = (1280, 720)
        self.setProperty('xRes',str(self.resolution[0]))
        self.setProperty('yRes', str(self.resolution[1]))
        self.setProperty('dWidth', str(self.width))
        self.setProperty('dHeight', str(self.height))
        leftpos = (self.resolution[0] - self.width) / 2
        toppos = (self.resolution[1] - self.height) / 2
        self.setProperty('dLeftPos',str(leftpos))
        self.setProperty('dTopPos', str(toppos))
        self.connectToServer()


    def closeBusyDialog(self):
        myLog("****closeBusyDialog Called...")
        self.bDialog.Stop()

    @TS_decorator
    def connectToServer(self):
        try:
            address = (ServerHost, ServerPort)
            self.client = PL_Client(address)
            myLog("**Client Connected")
            self.client.addDataReceivedEventHandler(self.onResponseReceived)
            self.client.addNotificationReceivedEventHandler(self.onNotificationReceived)
        except: pass


    def onInit(self):
        super(GUI, self).onInit()
        winID = xbmcgui.getCurrentWindowDialogId()
        self.queue.put(winID)
        myLog("*******My WinID is %s......" % winID)
        myLog("dLeftPos: %s" % self.getProperty('dLeftPos'))
        # ctrl = self.getControl(900)
        # ctrl.setPositon(190,0)
        #self.setProperty("xxx","abcd efgh")
        # define a temporary list where we are going to add all the listitems to
        listitems = []

        # hdrlistitems = []
        # hdrlistitems.append(xbmcgui.ListItem('My Header'))
        # hdrctr = self.getControl(30)
        # hdrctr.addItem(BuildHeader())

        """
        data = {'LTVPL0': {u'ch': 6.1, u'title': u'NBC Nightly News', u'alarmtime': u'2018-03-12 18:30:00',
                           u'expiryDate': u'2018-03-13 18:30:00', u'recurrenceInterval': u'WEEKDAYS',
                           u'id': u'18c6bf09e771ac7512ee6512e536a16d'},
                'LTVPL1': {u'ch': 10.1, u'title': u'The View', u'alarmtime': u'2018-03-12 11:00:00',
                           u'expiryDate': u'2018-04-12 18:30:00', u'recurrenceInterval': u'WEEKDAYS',
                           u'id': u'ee855f29bb180772a45b526724c17500'}}
        for key in data:
            plItem = BuildPlaylistItem(data[key])
            listitems.append(plItem)
        """
        """
        for i in range(7):
            listitems.append(xbmcgui.ListItem("hello"))
        """

        # by default the built-in container already contains one item, the 'up' (..) item, let's remove that one
        self.clearList()
        # now we are going to add all the items we have defined to the (built-in) container
        # Wait for data to come from the server before proceeding
        self.signal.clear()
        if self.client is not None:
            myLog("***Calling GetPlaylist....")
            self.client.GetPlayList()
            self.signal.wait(30.0)  # playlist has been set

        myLog("***Got the Playlist")
        self.addItems(listitems)
        self.sortItemListByDate()
        myLog("***Finshed Processing Playlist...")
        self.setProperty('Go', '1')
        # give kodi a bit of (processing) time to add all items to the container
        xbmc.sleep(100)
        # this puts the focus on the top item of the container

        # ctrl = self.getControl(50)
        # ctrl.setFocus(ctrl)
        # ctrl.selectItem(0)

        # xbmc.executebuiltin("Action(Right)")
        # xbmc.sleep(100)
        # xbmc.executebuiltin("Action(Right)")
        # xbmc.executebuiltin("Action(Left)")
        # xbmc.sleep(100)
        #xbmc.executebuiltin("Action(Left)")
        self.setCurrentListPosition(0)
        self.setFocusId(MAIN_LIST)
        self.closeBusyDialog()


    def onClick(self, controlId):
        myLog("***onClick ctl: %s" % controlId)
        #self.onFocus(100)
        if controlId == 20:
            #xbmc.executebuiltin("Action(PreviousMenu)")
            self.closeDialog()

    def closeDialog(self):
        window_id = xbmcgui.getCurrentWindowId()
        if self.client is not None:
            self.client.closeConnection()

        self.shutdown = True
        self.close()
        xbmc.sleep(100)
        #xbmc.executebuiltin("Dialog.Close(%s, true)" % window_id)
        # xbmc.executebuiltin("Action(Right)")
        # xbmc.executebuiltin("Action(Left)")
        # xbmc.executebuiltin("Action(Back)")


    def ShutdownState(self):
        myLog("******ShutdownState: %s" % self.shutdown)
        return self.shutdown

    def onAction(self, actionID):
        if type(actionID) == int:
            myLog("***Main onAction actionID: %d" % actionID)
        else:
            myLog("****Main onAction actionID: %d" % actionID.getId())

        if actionID == ACTION_NAV_BACK or actionID == ACTION_PREVIOUS_MENU:
            self.closeDialog()

        elif addonID == ACTION_MOVE_LEFT or addonID == ACTION_MOVE_RIGHT:
            pass

        elif actionID == ACTION_MOVE_DOWN and self.getFocusId() == 50:
            index = self.getCurrentListPosition()
            myLog("***Main ActionDown: %d" % index)
            if index == self.getListSize():
                self.setCurrentListPosition(0)

        elif actionID == ACTION_MOVE_UP  and self.getFocusId() == 50:
            index = self.getCurrentListPosition()
            myLog("***Main ActionUp: %d" % index)
            if index < 0:
                self.setCurrentListPosition(self.getListSize() - 1)

        elif actionID == ACTION_SELECT_ITEM:
            #TODO Call popup context menu
            pos = self.getCurrentListPosition()
            item = self.getListItem(pos)
            myLog("***********>Item Selected: {} at {}".format(item.getProperty('Description'),self.currentPos))
            window_id = xbmcgui.getCurrentWindowId()
            cmd = contextmenu.showMenu(addonID, ContextMenuItems, self.ShutdownState)
            myLog("************Cmd:%s" % cmd)
            if cmd is not None:
                id = item.getProperty('ID')
                if cmd == MENU_DELETE_ITEM:
                    myLog("******Delete Event Selected")
                    self.client.RemovePlayListItem(id)
                elif cmd == MENU_SKIP_ITEM:
                    myLog("******Skip Event Selected")
                    self.client.SkipPlayListItem(id)
                elif cmd == MENU_SUSPEND_ITEM:
                    myLog("******Suspend Event Selected")

    def onFocus(self, ctrlID):
        ctrl = self.getControl(ctrlID)
        if ctrlID == MAIN_LIST:
            ctrl.selectItem(0)
        self.currentPos = ctrl.getPosition()
        myLog("******CurrentPos: {}\tctrlID: {}".format(self.currentPos, ctrlID))

    def getItemList(self):
        maxitems = self.getListSize()
        ilist = [self.getListItem(pos) for pos in range(maxitems)]
        return ilist

    def sortItemListByDate(self):
        itemlist = self.getItemList()
        newlist = sorted(itemlist, key=lambda item: item.getProperty('Date')+item.getProperty('Time')[-2:]
                                                    +item.getProperty('Time')[:-3])
        self.clearList()
        self.addItems(newlist)

        # for item in newlist:
        #     myLog("date:{}\ttime:{}\n".format(item.getProperty('Date'), item.getProperty('Time')))

    def findItemByID(self, id):
        maxitems = self.getListSize()
        for i in range(maxitems):
            item = self.getListItem(i)
            if id == item.getProperty('ID'):
                return (item, i)

        raise(Exception("Item ID %s Not Found" % id))

    def updateItemByID(self, id, data):
        hdrkeys = getHdrKeys()
        #myLog("********hdrkeys: %s" % hdrkeys)
        try:
            item, pos = self.findItemByID(id)
            myLog("******updateItemByID - found id:{} at pos:{}".format(id,pos))
            if item is not None:
                #myLog("******updateItemByID - call BuildPlaylistItem():{}".format(data))
                update = BuildPlaylistItem(data)
                #myLog("****Back from BuildPlaylistItem call")
                for key in hdrkeys:
                    #myLog("******item.getProperty({}):{}\n******update.getProperty({}):{}".
                             #format(key,item.getProperty(key),key,update.getProperty(key)))
                    if item.getProperty(key) != update.getProperty(key):
                        #myLog("*******ChangedProperty:{}:{}".format(key, update.getProperty(key)))
                        item.setProperty(key, update.getProperty(key))
        except: pass
        self.sortItemListByDate()

    def removeItemByID(self, id):
        try:
            myLog("**********Calling findItemByID......")
            pos = self.findItemByID(id)[1]
            myLog("***removeItemByID Found itemID:{} at pos:{}".format(id,pos))
            self.removeItem(pos)
        except Exception as e:
            myLog(e.message)


    def addNewItem(self, data):
        try:
            item = BuildPlaylistItem(data)
            self.addItem(item)
        except: pass
        self.sortItemListByDate()

    def clearItems(self):
        self.clearList()

    def onNotificationReceived(self,msg):
        """
        Decode the notification message and perform the appropriate function.
        Decoded Functions:
            1. ItemAdded
            2. ItemCancelled
            3. ItemUpdated
            4. ItemRemoved
            5. VacationMode
        The purpose of this function is to update the GUI display based on feedback from the server
        :param msg: Notification String
        :return:
        """
        myLog("***Notification: {}".format(msg))
        try:
            cmd, data = genericDecode(msg)
            myLog("****cmd:{}\tdata:{}\n".format(cmd,data))
            if not self.blockNotification:
                if cmd == NotificationAction.ItemRemoved:
                    id = data['id']
                    myLog("****self.removeItemByID(%s)" % id)
                    self.removeItemByID(id)

                if cmd == NotificationAction.ItemAdded:
                    myLog("****self.addNewItem(%s)" % data)
                    self.addNewItem(data)

                if cmd == NotificationAction.ItemUpdated:
                    id = data['id']
                    myLog("****self.updateItemByID(%s,%s)" % (id,data))
                    self.updateItemByID(id, data)

                if cmd == NotificationAction.VacationMode:
                    myLog("VacationMode: %s" % data)

        except:
            pass




    def onResponseReceived(self, cmd, data):
        myLog("**DataResponse Received: {}".format(data))
        #self.blockNotification = True
        if cmd == Cmd.GetChannelList:
            pass

        elif cmd == Cmd.GetPlayList:
            dataSetData = data
            ilist = []
            for key in dataSetData:
                myLog("**Data: {}".format(dataSetData[key]))
                ilist.append(BuildPlaylistItem(dataSetData[key]))

            self.addItems(ilist)
            self.signal.set()

        elif cmd == Cmd.AddPlayListItem:
            myLog("********onResponseReceived.addPlayListItem: %s" % data)
            self.addNewItem(data)

        elif cmd == Cmd.UpdatePlayListItem or cmd == Cmd.SkipEvent:
            myLog("********onResponseReceived.UpdatePlayListItem: %s" % data)
            id = data['id']
            self.updateItemByID(id,data)

        elif cmd == Cmd.RemovePlayListItem:
            myLog("********onResponseReceived.RemovePlayListItem: %s" % data)
            id = data['id']
            self.removeItemByID(id)

        elif cmd == Cmd.GetChGroupList:
            pass

@TS_decorator
def showMainDialog(bDialog, queue):
    myLog("*********Calling Main Dialog")
    ui = GUI('Default', '720p', bDialog, queue)
    ui.doModal()
    myLog("***Main I'm After doModal()")
    del ui


@TS_decorator
def showEPGCaptureDialog(busydialog):
        getEPG_Data()
        EPGcapture.showDialog(addonID, busydialog.Stop)

#@TS_decorator
def ShowBusyDialog(bDialog,queue,tmpBD):
    myLog("****Activating Busy Dialog...")
    winID = queue.get(True, None)
    tmpBD.Stop()
    xbmc.sleep(1000)
    while not xbmc.getCondVisibility("Window.IsVisible(%s)" % winID):
        xbmc.sleep(500)

    myLog("****Main winID: %s" % winID)
    bDialog.show()


if (__name__ == '__main__'):
    import EPGcapture
    queue = Queue()
    bDialog = myBusyDialog()

    if checkForEPG():
        showEPGCaptureDialog(bDialog)
        bDialog.show()
    else:
        # tmpBD=myBusyDialog()
        # xbmc.log("*****Showing tmp busy...")
        # tmpBD.show()
        showMainDialog(bDialog, queue)
        # ShowBusyDialog(bDialog,queue,tmpBD)

        # xbmc.sleep(1500)
        # tmp.Stop()

    del bDialog

